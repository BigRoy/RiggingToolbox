/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;


//////////////////////////////////////
// Factory definition.

object ComputeNormalsModifierFactory : GeometryOperatorFactory {
};

function GeometryOperator ComputeNormalsModifierFactory.constructGeometryOperator(){
  ComputeNormalsModifier geomOp();
  return geomOp;
}


//////////////////////////////////////
//


object ComputeNormalsModifier : BaseModifier {

  UInt32 boundVersion;

  Boolean displayDebugging;
  Lines lines[];
  DrawingHandle handle;
};

function ComputeNormalsModifier(){
  this.parent.init();
  this.displayDebugging = false;
}


function UInt32[String] ComputeNormalsModifier.getAttributeInteractions(){
  UInt32 result[String];
  result['positions'] = AttrMode_Read;
  result['normals'] = AttrMode_Write;
  return result;
}

inline Vec3 computeNormalsModifier_triNrm(Vec3 vec1, Vec3 vec2){
  Vec3 triNrm = vec1.cross(vec2);
  Float32 lenSq = triNrm.lengthSquared();
  if(lenSq > DIVIDEPRECISION)
    return triNrm / sqrt(lenSq);
  return Vec3();
}

operator computeNormalsModifier_computePointNormals<<<index>>>(
  PolygonMeshTopology mesh,
  Vec3 positions[],
  io Vec3 normals[],
  Boolean displayDebugging,
  io UInt32 debugLinesindices[],
  io Vec3 debugLinespositions[]
){
  Vec3 point = positions[index];

  LocalL16UInt32Array surroundingPoints;
  mesh.getPointSurroundingPoints( index, false, surroundingPoints );
  UInt32 nbNei = surroundingPoints.size();
  if(nbNei > 0){
    Vec3 vec2, vec1 = positions[surroundingPoints.get(0)] - point;
    Vec3 vec0 = vec1;
    Vec3 nrm();
    for(UInt32 i=1; i<surroundingPoints.size(); i++){
      vec2 = positions[surroundingPoints.get(i)] - point;
      nrm += computeNormalsModifier_triNrm(vec1, vec2);
      vec1 = vec2;
    }
    nrm += computeNormalsModifier_triNrm(vec1, vec0);
    Float32 lenSq = nrm.lengthSquared();
    if(lenSq > DIVIDEPRECISION){
      Vec3 normal = nrm / sqrt(lenSq);
      mesh.setPointAttribute( index, normals, normal );

      if(displayDebugging){
        debugLinesindices[(index*2)] = (index*2);
        debugLinesindices[(index*2)+1] = (index*2)+1;
        debugLinespositions[(index*2)] = point;
        debugLinespositions[(index*2)+1] = point + normal;
      }
    }
  }

}

/// Per-geometry computation of the push. 
/// \internal
operator computeNormalsModifier_modifyGeometries<<<index>>>(
  io GeometrySet geomSet,
  Boolean displayDebugging,
  io Lines lines[],
  Boolean useGPU
){
  PolygonMesh mesh = geomSet.get(index);
  if(mesh){

    DebugLines debugLines;
    if(displayDebugging){
      if(lines[index] == null)
        lines[index] = Lines();
      if(lines[index].lineCount() != mesh.pointCount()){
        lines[index].attributes.resize( mesh.pointCount() * 2 );
        lines[index].indices.resize( mesh.pointCount() * 2 );
        lines[index].incrementVersion();
      }
      debugLines.init(lines[index]);
      if(useGPU)
        debugLines.convertToGPU();
      else
        debugLines.convertToCPU();

      // Always increment the positoins version as they will be re-geomuted in the following kernel.
      lines[index].attributes.positionsAttribute.incrementVersion();
    }

    // DebugLines debugLines(lines[index]);

    Ref<Vec3Attribute> normalsAttribute = mesh.getOrCreateNormals();
    if(useGPU){
      if(normalsAttribute.getElementsMemType() == 0)
        normalsAttribute.convertToGPU();
    }

    // Note: the builtin normal computation manages splitting attribtiues along hard edges,
    // and this causes corruption of the skinning attribute. The custom implementation above
    // is naive and assumes no hard edges, but can also run on the GPU.
    computeNormalsModifier_computePointNormals<<<mesh.pointCount()@useGPU>>>(
      mesh.topology,
      mesh.positionsAttribute.values,
      normalsAttribute.values,
      displayDebugging,
      debugLines.indices,
      debugLines.positions
      );
    normalsAttribute.incrementVersion();
  }
}

function ComputeNormalsModifier.evaluate!(EvalContext context, io GeometrySet geomSet){
  AutoProfilingEvent p(FUNC);

  if(geomSet.getVersion() != this.boundVersion){
    this.lines.resize(geomSet.size());
    this.boundVersion = geomSet.getVersion();
  }

  computeNormalsModifier_modifyGeometries<<<geomSet.size()>>>(geomSet, this.displayDebugging, this.lines, this.useGPU());

  if(this.displayDebugging && this.handle==null)
    this.setupRendering();
  else if(!this.displayDebugging && this.handle!=null)
    this.handle = null;
}

function ComputeNormalsModifier.setupRendering!(){

  // Construct a handle for this character instance. The handle will clean up the InlineDrawing when it is destroyed. 
  this.handle = DrawingHandle("WrapModifierHandle");

  // Now setup the rendering
  InlineShader shader = this.handle.getDrawing().registerShader(OGLFlatOverlayShader());
  InlineMaterial material = shader.getOrCreateMaterial("ComputeNormalsModifierMaterial");

  for(Integer geomId=0; geomId<this.lines.size(); geomId++){
    String name = "ComputeNormalsModifier_" + String(geomId);
    InlineShape shape = InlineLinesShape(name, this.lines[geomId]);
    InlineInstance instance = SimpleInlineInstance(name + "_Instance", this.handle.rootTransform, shape, material);
    instance.setInstanceUniform(InlineUniform('u_color', Color(0.0,1.0,0.0)));
  }
}


function JSONDictValue ComputeNormalsModifier.saveJSON(PersistenceContext persistenceContext){
  JSONDictValue json = this.parent.saveJSON(persistenceContext);
  json.setBoolean('displayDebugging', this.displayDebugging);
  return json;
}

function ComputeNormalsModifier.loadJSON!(PersistenceContext persistenceContext, JSONDictValue json){
  this.parent.loadJSON(persistenceContext, json);
  if(json.has('displayDebugging'))
    this.displayDebugging = json.getBoolean('displayDebugging');
}