/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;


//////////////////////////////////////
// Factory definition.

object BlendShapesModifierFactory : GeometryOperatorFactory {
};

function GeometryOperator BlendShapesModifierFactory.constructGeometryOperator(){
  BlendShapesModifier geomOp();
  return geomOp;
}


//////////////////////////////////////
//


struct BlendShapesModifier_Target {
  UInt32 indices[];
  Vec3 deltas[];

  OGLBuffer buffers[2];
  CudaGLResource resources[2];
};

inline UInt32 BlendShapesModifier_Target.pointCount(){
  return this.indices.size;
}

function BlendShapesModifier_Target.loadToOGLBuffer!( ) {
  if(this.buffers][0] == null)
    this.buffers][0] = OGLBuffer();
  this.buffers][0].genBuffer(this.indices.data(), this.indices.dataSize(), this.indices.size());
  // TODO: flag this resource as 'readonly'. check performance. 
  this.resources[0] = CudaGLResource(this.buffers][0].bufferID);

  if(this.buffers[1] == null)
    this.buffers[1] = OGLBuffer();
  this.buffers[1].genBuffer(this.deltas.data(), this.deltas.dataSize(), this.deltas.size());
  // TODO: flag this resource as 'readonly'. check performance. 
  this.resources[1] = CudaGLResource(this.buffers[1].bufferID);
}

inline BlendShapesModifier_Target.map!(){
  for(UInt32 i=0; i<2; i++)
    this.resources[i].map();
}
inline BlendShapesModifier_Target.unmap!(){
  for(UInt32 i=0; i<2; i++)
    this.resources[i].unmap();
}

inline UInt32<> BlendShapesModifier_Target.getIndices(Boolean useGPU){
  if(useGPU)
    return this.resources[0].getVec3Array();
  else
    return this.indices;
}

inline Vec3<> BlendShapesModifier_Target.getDeltas(Boolean useGPU){
  if(useGPU)
    return this.resources[1].getUInt32Array();
  else
    return this.deltas;
}


//////////////////////////////////////
//


/// The Blend Shapes modifier stores a sparce data set of offsets. 
object BlendShapesModifier : BaseModifier {
  String filePath;
  String referenceGeometryName;
  String targetGeometryNames[];

  Vec3 referencePositions[][];
  BlendShapesModifier_Target targets[][];
  Scalar threshold;

  Scalar weights[];

  Boolean buffersLoaded;
};


function BlendShapesModifier(){
  this.threshold = 0.001;
}



//////////////////////////////////////
//


inline String BlendShapesModifier_getNameFromPath(String pathStr) {
  String path[] = pathStr.split('/');
  return path[path.size-1];
}

/// Loads the data from the alembic file
/// \internal
function BlendShapesModifier.loadTargetsFromAlembic!(String basePath, String filePath){

  AutoProfilingEvent p(FUNC);
  // Check for an absolute file path, then a relative path.
  FilePath expandedPath = FilePath(filePath);
  expandedPath = expandedPath.expandEnvVars();

  if(expandedPath.isRelative()){
    expandedPath = FilePath(basePath) / expandedPath;
  }

  if(!expandedPath.exists()){
    report("File not found:" + expandedPath.string());
    return;
  }

  AlembicArchiveReader archive(expandedPath.string());
  String polymeshPaths[] = archive.getPathsOfType('PolyMesh');

  AlembicPolyMeshReader readers[];
  readers.resize(polymeshPaths.size());
  String refGeomNames[];

  for(UInt32 i=0; i<polymeshPaths.size(); i++) {
    String name = BlendShapesModifier_getNameFromPath(polymeshPaths[i]);
    if(applyNameFilter(name, this.referenceGeometryName)){
      AlembicPolyMeshReader reader = archive.getPolyMesh(polymeshPaths[i]);
      PolygonMesh mesh = PolygonMesh();
      reader.readSample(0.0, mesh);
      this.addReferenceGeometry(mesh);

      refGeomNames.push(name);
    }
  }

  for(UInt32 i=0; i<polymeshPaths.size(); i++) {
    String name = BlendShapesModifier_getNameFromPath(polymeshPaths[i]);

    if(applyNameFilters(name, this.targetGeometryNames)){
      AlembicPolyMeshReader reader = archive.getPolyMesh(polymeshPaths[i]);
      PolygonMesh mesh = PolygonMesh();
      reader.readSample(0.0, mesh);

      if(refGeomNames.size() == 1)
        this.addTargetGeometry(0, mesh);
      else{
        for(UInt32 j=0; j<refGeomNames.size(); j++) {
          if(name.startsWith(refGeomNames[j])){
            this.addTargetGeometry(j, mesh);
            break;
          }
        }
      }
    }
  }
}

//////////////////////////////////////
//

/// A struct for collecting points during surface painting.
/// \internal
struct BlendShapesModifier_collectGeomPointsSharedData {
  Vec3 positions[];
  Vec3 refpositions[];
  Scalar threshold;
};


/// A struct for collecting points during surface painting.
/// \internal
struct BlendShapesModifier_collectMeshPointsSharedData {
  PolygonMesh mesh;
  Vec3 refpositions[];
  Scalar threshold;
};

/// A struct for collecting points during surface painting.
/// \internal
struct BlendShapesModifier_CollectPointsMapOutput {
  Boolean collected;
  Integer index;
  Vec3 delta;
};


/// An operator for collecting points during surface painting.
/// \internal
operator blendShapesModifier_collectGeomPointsProduce(
  io BlendShapesModifier_CollectPointsMapOutput result,
  Index index,
  UInt32 count,
  BlendShapesModifier_collectGeomPointsSharedData sharedData
) {
  Vec3 pos = sharedData.positions[index];
  Vec3 delta = pos - sharedData.refpositions[index];
  if(delta.length() > sharedData.threshold){
    result.collected = true;
    result.index = index;
    result.delta = delta;
  }
}

/// An operator for collecting points during surface painting.
/// \internal
operator blendShapesModifier_collectMeshPointsProduce(
  io BlendShapesModifier_CollectPointsMapOutput result,
  Index index,
  UInt32 count,
  BlendShapesModifier_collectMeshPointsSharedData sharedData
) {
  Vec3 pos = sharedData.mesh.getPointPosition(index);
  Vec3 delta = pos - sharedData.refpositions[index];
  if(delta.length() > sharedData.threshold){
    result.collected = true;
    result.index = index;
    result.delta = delta;
  }
}


/// An operator for collecting points during surface painting.
/// \internal
operator blendShapesModifier_collectPointsReduce(
  BlendShapesModifier_CollectPointsMapOutput input,
  io BlendShapesModifier_Target output,
  Index index,
  UInt32 count
) {
  if(input.collected){
    output.indices.push(input.index);
    output.deltas.push(input.delta);
  }
}

// First add a reference geometry, followed by a collection of targets. 
// As the targets are added we generate our sparce blend targets based on the reference.
// This step must happen before evaluation. 
function BlendShapesModifier.addReferenceGeometry!(Geometry refGeometry){
  AutoProfilingEvent p(FUNC);

  UInt32 numGeoms = this.targets.size()+1;
  UInt32 geomIndex = numGeoms-1;
  this.targets.resize(numGeoms);
  this.referencePositions.resize(numGeoms);

  Ref<GeometryAttributes> attributes = refGeometry.getAttributes();
  Vec3Attribute positionsAttribute = attributes.positionsAttribute;
  this.referencePositions[geomIndex] = positionsAttribute.values;
}

function BlendShapesModifier.addTargetGeometry!(UInt32 geomIndex, Geometry targetGeometry){
  AutoProfilingEvent p(FUNC);

  UInt32 numTargets = this.targets[geomIndex].size()+1;
  UInt32 targetIndex = numTargets-1;
  this.targets[geomIndex].resize(numTargets);
  this.weights.resize(numTargets);

  PolygonMesh targetMesh = targetGeometry;
  if(!targetMesh){

    Ref<GeometryAttributes> attributes = targetGeometry.getAttributes();
    Vec3Attribute positionsAttribute = attributes.positionsAttribute;

    BlendShapesModifier_collectGeomPointsSharedData sharedData;
    sharedData.positions = positionsAttribute.values;
    sharedData.refpositions = this.referencePositions[geomIndex];
    sharedData.threshold = this.threshold;

    ValueProducer<BlendShapesModifier_Target> reducer = createReduce( 
      createArrayGenerator(
        createConstValue( attributes.size() ),
        blendShapesModifier_collectGeomPointsProduce,
        createConstValue( sharedData )
      ),
      blendShapesModifier_collectPointsReduce
    );
    this.targets[geomIndex][targetIndex] = reducer.produce();
  }
  else{
    BlendShapesModifier_collectMeshPointsSharedData sharedData;
    sharedData.mesh = targetMesh;
    sharedData.refpositions = this.referencePositions[geomIndex];
    sharedData.threshold = this.threshold;

    ValueProducer<BlendShapesModifier_Target> reducer = createReduce( 
      createArrayGenerator(
        createConstValue( targetMesh.pointCount() ),
        blendShapesModifier_collectMeshPointsProduce,
        createConstValue( sharedData )
      ),
      blendShapesModifier_collectPointsReduce
    );
    this.targets[geomIndex][targetIndex] = reducer.produce();
  }
}



function BlendShapesModifier.setBlendWeights!(Scalar weights[]){
  this.weights = weights;
  String data;
  this.notify('changed', data);
}


//////////////////////////////////////
//

operator blendShapesModifier_applyGeomDeltas<<<index>>>(
  io Vec3 positions[],
  UInt32 targetIndices<>,
  Vec3 targetDeltas<>,
  Scalar weight
){
  positions[targetIndices[index]] += targetDeltas[index] * weight;
}

operator blendShapesModifier_applyMeshDeltas<<<index>>>(
  io PolygonMesh mesh,
  UInt32 targetIndices<>,
  Vec3 targetDeltas<>,
  Scalar weight
){
  Vec3 pos = mesh.getPointPosition(targetIndices[index]);
  mesh.setPointPosition(targetIndices[index], pos + (targetDeltas[index] * weight));
}


operator blendShapesModifier_deformGeometries<<<index>>>(
  Boolean useGPU,
  io GeometrySet geomSet,
  BlendShapesModifier_Target targets[][],
  Scalar weights[]
){
  Geometry geom = geomSet.get(index);
  Ref<GeometryAttributes> attributes = geom.getAttributes();
  Vec3Attribute positionsAttribute = attributes.positionsAttribute;
  
  PolygonMesh mesh = geom;
  for(UInt32 i=0; i<targets[index].size; i++){
    if(!mesh){
      blendShapesModifier_applyGeomDeltas<<<targets[index][i].pointCount()@useGPU>>>(
        positionsAttribute.values,
        targets[index][i].getIndices(useGPU),
        targets[index][i].getDeltas(useGPU),
        weights[i]
      );
    }
    else{
      blendShapesModifier_applyMeshDeltas<<<targets[index][i].pointCount()@useGPU>>>(
        mesh,
        targets[index][i].getIndices(useGPU),
        targets[index][i].getDeltas(useGPU),
        weights[i]
      );
    }
  }
  positionsAttribute.incrementVersion();
}

function BlendShapesModifier.evaluate!(EvalContext context, io GeometrySet geomSet){
  AutoProfilingEvent p(FUNC);

  Boolean useGPU = false;
  if(useGPU){
    if(!this.buffersLoaded){
      for(UInt32 i=0; i<this.targets.size; i++){
        for(UInt32 j=0; j<this.targets[i].size; j++){
          this.targets[i][j].loadToOGLBuffer();
        }
      }
    }
    for(UInt32 i=0; i<this.targets.size; i++){
      for(UInt32 j=0; j<this.targets[i].size; j++){
        this.targets[i][j].map();
      }
    }
  }

  blendShapesModifier_deformGeometries<<<geomSet.size()>>>(useGPU, geomSet, this.targets, this.weights);

  if(useGPU){
    for(UInt32 i=0; i<this.targets.size; i++){
      for(UInt32 j=0; j<this.targets[i].size; j++){
        this.targets[i][j].unmap();
      }
    }
  }
}


function JSONDictValue BlendShapesModifier.saveJSON(PersistenceContext persistenceContext){
  JSONDictValue json = this.parent#saveJSON(persistenceContext);
  json.setString('filePath', this.filePath);
  json.setString('referenceGeometryName', this.referenceGeometryName);

  JSONArrayValue targetGeometryNamesData();
  for(Integer i=0; i<this.targetGeometryNames.size; i++)
    targetGeometryNamesData.addString(this.targetGeometryNames[i]);
  json.set('targetGeometryNames', targetGeometryNamesData);

  return json;
}

function BlendShapesModifier.loadJSON!(PersistenceContext persistenceContext, JSONDictValue json){
  this.parent#loadJSON(persistenceContext, json);

  if(json.has('filePath')){
    this.filePath = json.getString('filePath');


    // The Alembic file should contain a collection of geometries that are grouped by naming convention.
    // referenceGeometryName:'MyGeometry' <- The reference geometry used to compute the blend shapes. 
    // targetGeometryNames: [ 'MyGeometry_Shape1', 'MyGeometry_Shape2', 'MyGeometry_Shape3'] <- Shape targets

    this.referenceGeometryName = json.getString('referenceGeometryName');

    JSONArrayValue targetGeometryNamesData = json.get('targetGeometryNames');
    if(targetGeometryNamesData)
      this.targetGeometryNames = targetGeometryNamesData.toStringArray();
    
    this.loadTargetsFromAlembic(persistenceContext.filePath, this.filePath);
  }
}


/// Generates a Description string of this pose.
/// \param indent The indentation to use when generating the string. 
function String BlendShapesModifier.getDesc(String indent) {
  String desc;
  desc += indent + "{\n";
  desc += indent + "  type: "+ this.type() + ",\n";
  desc += indent + "  filePath: "+ this.filePath + "\n";
  desc += indent + "  refGeoms: "+ this.targets.size + "\n";
  for(Integer i=0; i<this.targets.size; i++)
    desc += indent + "    blendTargets: "+ + i +":" + this.targets[i].size + "\n";
  desc += indent + "}";
  return desc;
}

