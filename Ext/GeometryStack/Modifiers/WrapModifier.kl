/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;
require Manipulation;


//////////////////////////////////////
// Factory definition.

object WrapModifierFactory : GeometryOperatorFactory {
};

function GeometryOperator WrapModifierFactory.constructGeometryOperator(){
  WrapModifier geomOp();
  return geomOp;
}


//////////////////////////////////////
//

// TODO: eliminate the use of the Geometry types in the compute step.
struct WrapModifier_Location {
  UInt32 attributeIndices[3];
  Scalar weights[3];
};

object WrapModifier : BaseModifier {
  GeometryLocation locations[][];
  Vec3 deltas[][];
  GeometryStack sourceGeometryStack;

  Boolean bound;
  UInt32 boundVersion;
  UInt32 srcBoundVersion;
};


function WrapModifier(){
}

function Mat44 wrapModifier_buildRefFrame(Vec3 pos, Vec3 nrm, Vec4 tngnt){
  return Mat44();
}

operator wrapModifier_computeBinding<<<index>>>(
  PolygonMesh srcMesh,
  Vec3Attribute srcPositionsAttribute,
  Vec3Attribute srcNormalsAttribute,
  Vec4Attribute srcTangentsAttribute,
  io GeometryLocation locations[],
  io Vec3 deltas[],
  Vec3 positions[],
){
  Vec3 position = positions[index];
  Vec3 scaling(1.0, 1.0, 1.0);
  GeometryLocation location = srcMesh.getClosest( position, scaling, SCALAR_INFINITE );

  Vec3 pos = GetAttributeAtLocation( srcMesh, location, srcPositionsAttribute );
  Vec3 nrm = GetAttributeAtLocation( srcMesh, location, srcNormalsAttribute );
  Vec4 tgt = GetAttributeAtLocation( srcMesh, location, srcTangentsAttribute );

  // Build a reference frame. 
  Mat44 mat44 = wrapModifier_buildRefFrame(pos, nrm, tgt);

  deltas[index] = mat44.inverse() * position;
  locations[index] = location;
}

operator wrapModifier_applyDeltas<<<index>>>(
  PolygonMesh srcMesh,
  Vec3Attribute srcPositionsAttribute,
  Vec3Attribute srcNormalsAttribute,
  Vec4Attribute srcTangentsAttribute,
  GeometryLocation locations[],
  Vec3 deltas[],
  io Vec3 positions[],
){
  GeometryLocation location = locations[index];
  Vec3 pos = GetAttributeAtLocation( srcMesh, location, srcPositionsAttribute );
  Vec3 nrm = GetAttributeAtLocation( srcMesh, location, srcNormalsAttribute );
  Vec4 tgt = GetAttributeAtLocation( srcMesh, location, srcTangentsAttribute );

  Mat44 mat44 = wrapModifier_buildRefFrame(pos, nrm, tgt);
  positions[index] = mat44 * deltas[index];
}


operator wrapModifier_deformGeometries<<<index>>>(
  io GeometrySet geomSet,
  GeometrySet srcGeomSet,
  io GeometryLocation locations[][],
  io Vec3 deltas[][],
  Boolean bound
){
  PolygonMesh srcMesh = srcGeomSet.get(0);
  if(!srcMesh){
    // Note: The source GeometrySet could contain multiple meshes to deform the target geoms.
    // There could be a mapping generates from the target meshes to the source meshes on a per-point
    // basis. For now we just expect one polymesh as the source. 
    report("Warning in wrapModifier_deformGeometries: Source GeometrySet does not contain a polygon mesh.");
    return;
  }

  Ref<GeometryAttributes> attributes = geomSet.get(index).getAttributes();
  Vec3Attribute positionsAttribute = attributes.positionsAttribute;

  // Gather the attributes from the source mesh that will be used to 
  // drive the point positions of the target meshes.
  Ref<Vec3Attribute> srcPositionsAttribute = srcMesh.positionsAttribute;
  Ref<Vec3Attribute> srcNormalsAttribute = srcMesh.normalsAttribute;
  Ref<Vec4Attribute> srcTangentsAttribute = srcMesh.getAttribute("tangents");

  if(!bound){

    srcMesh.prepareForSpatialQueries(positionsAttribute.size(), null );
    Ref<SpatialQuery> query = srcMesh.beginSpatialQuery();

    locations[index].resize(positionsAttribute.size());
    deltas[index].resize(positionsAttribute.size());

    wrapModifier_computeBinding<<<positionsAttribute.size()>>>(
      srcMesh,
      srcPositionsAttribute,
      srcNormalsAttribute,
      srcTangentsAttribute,
      locations[index],
      deltas[index],
      positionsAttribute.values
    );
    srcMesh.endSpatialQuery(query);
  }
  else{
    wrapModifier_applyDeltas<<<positionsAttribute.size()>>>(
      srcMesh,
      srcPositionsAttribute,
      srcNormalsAttribute,
      srcTangentsAttribute,
      locations[index],
      deltas[index],
      positionsAttribute.values
    );
    positionsAttribute.incrementVersion();
  }
}

function WrapModifier.evaluate!(EvalContext context, io GeometrySet geomSet){
  AutoProfilingEvent p(FUNC);

  Ref<WrapModifier> io_this = this;
  GeometrySet srcGeomSet = io_this.sourceGeometryStack.evaluate(context);

  if(srcGeomSet.getVersion() != io_this.srcBoundVersion || geomSet.getVersion() != this.boundVersion){
    io_this.bound = false;
  }
  wrapModifier_deformGeometries<<<geomSet.size()>>>(geomSet, srcGeomSet, io_this.locations, io_this.deltas, io_this.bound);

  if(!io_this.bound){
    io_this.srcBoundVersion = srcGeomSet.getVersion();
    io_this.boundVersion = geomSet.getVersion();
    io_this.bound = true;
  }
}


\