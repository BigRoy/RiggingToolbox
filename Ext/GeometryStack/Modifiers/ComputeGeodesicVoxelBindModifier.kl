/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;

//////////////////////////////////////
// Factory definition.
object ComputeGeodesicVoxelBindModifierFactory : GeometryOperatorFactory {
};

function GeometryOperator ComputeGeodesicVoxelBindModifierFactory.constructGeometryOperator(){
  ComputeGeodesicVoxelBindModifier geomOp();
  return geomOp;
}


//////////////////////////////////////
// ComputeGeodesicVoxelBindModifier

// Based roughly on http://www.delasa.net/data/sca2013_voxelization.pdf
object ComputeGeodesicVoxelBindModifier : BaseModifier {
  Scalar falloff; // user parameter between 0 to 1
};


function UInt32[String] ComputeGeodesicVoxelBindModifier.getAttributeInteractions(){
  UInt32 result[String];
  result['positions'] = AttrMode_Read;
  result['skinningData'] = AttrMode_Write;
  return result;
}

//////////////////////////////////////
// Compute Bone Voxel Distances

// Compute the distance between each bones' position towards all Voxel centers
// with a form of Dijkstra's algorithm
function ComputeGeodesicVoxelBindModifier.computeDistances(Voxelizer voxelizer,
                                                           Boolean voxels[Vec3_i],
                                                           Mat44 bones[],
                                                           out Scalar voxelBoneDistances[][Vec3_i])
{
  // Predefined set of neighbour offsets used to easily
  // iterate towards each neighbour voxel
  Vec3_i neighbours[6];
  neighbours[0] = Vec3_i(-1, 0, 0);
  neighbours[1] = Vec3_i(1, 0, 0);
  neighbours[2] = Vec3_i(0, -1, 0);
  neighbours[3] = Vec3_i(0, 1, 0);
  neighbours[4] = Vec3_i(0, 0, -1);
  neighbours[5] = Vec3_i(0, 0, 1);

  voxelBoneDistances.resize(bones.size());

  for(Size i=0; i<bones.size(); i++)
  {
    // Voxel distances for the current bone
    Scalar voxelDistances[Vec3_i];

    // Initialize voxel distance values to infinite
    for(key in voxels)
    {
      voxelDistances[key] = SCALAR_INFINITE;
    }

    // Identify the voxel intersecting the bone (skeleton) and
    // set this distance to zero
    Vec3 bonePos = bones[i].translation();
    Vec3_i boneVoxelIndex = voxelizer.getVoxelIndex(bonePos);
    voxelDistances[boneVoxelIndex] = 0; // zero distance for this voxel

    // Compute geodesic distance using a form of dijkstra's algorithm
    // Iterate all neighbours and increase voxel distance as we go
    QueueVec3_i queue; // first-in-first-out
    queue.enqueue(boneVoxelIndex);

    Integer dist; 
    while(!queue.isEmpty())
    {
      Vec3_i currentIndex = queue.front();
      queue.dequeue(); // pop from queue

      // Neighbour distance is plus one in voxel space
      dist = voxelDistances[currentIndex] + 1;

      for(Size x=0; x<neighbours.size(); x++)
      {
        Vec3_i neighbourIndex = currentIndex + neighbours[x];
        if (voxels.has(neighbourIndex)) // Check if neighbour exists
        {  
            // If the stored distance for the bone is currently higher (eg. infinite) 
            // than the computed weight it means we still have to traverse it
            // since it's closer than expected, so set it and add it to the queue
            if (voxelDistances[neighbourIndex] > dist)
            {
              voxelDistances[neighbourIndex] = dist;
              queue.enqueue(neighbourIndex);
            }
        }
      }
    }

    // Assign the distances for this bones
    voxelBoneDistances[i] = voxelDistances;
  }
}


//////////////////////////////////////
// Compute weights based on the voxelBoneDistances calculated in ComputeGeodesicVoxelBind.computeDistances()
function ComputeGeodesicVoxelBindModifier.computeWeights(in Voxelizer voxelizer,
                                                         in PolygonMesh mesh,
                                                         in Scalar cellSizeInv, 
                                                         in Vec3 bbSize,
                                                         in Scalar voxelBoneDistances[][Vec3_i],
                                                         out Scalar boneVertexWeights[][]
                                                   )
{

  Scalar epsilon = 0.00001;

  // Resize to number of bones
  boneVertexWeights.resize(voxelBoneDistances.size());

  // Get mesh vertices
  Size pointCount = mesh.pointCount();
  Ref<GeometryAttributes> attributes = mesh.getAttributes();
  Vec3Attribute positionsAttribute = attributes.positionsAttribute;
  Vec3 points[] = positionsAttribute.values;

  Scalar cellSize = voxelizer.cellSize;
  Scalar bbExtends = bbSize.x * bbSize.y * bbSize.z;

  Scalar voxelDistances[Vec3_i];

  // For each bone go through all vertices, find their voxel and set the
  // weights using the calculated geodesic voxelBoneDistances
  for(Size boneIndex = 0; boneIndex<voxelBoneDistances.size(); boneIndex++)
  {
     Scalar vertexWeights[] = boneVertexWeights[boneIndex];
     vertexWeights.resize(pointCount);

     voxelDistances = voxelBoneDistances[boneIndex];
     
     for(Size j=0; j<pointCount; j++)
     {
        // Get voxel for point
        Vec3_i voxelIndex = voxelizer.getVoxelIndex(points[j]);

        if (!voxelDistances.has(voxelIndex))
        {
          // This should never happen. All vertices should be in the voxels.
          report("Warning: Vertex' voxel index " + voxelIndex + " is not in the voxelBoneDistances.");
          vertexWeights[j] = 0;
          continue;
        }
        
        // Get the calculated distance for the bone in the voxel (in voxel space)
        Scalar boneDistance = voxelDistances[voxelIndex];

        // Convert to world space size from voxel space
        boneDistance *= cellSize;

        // To compensate for the voxel gridâ€™s coarseness, and the fact that multiple vertices
        // may fall in the same voxel, we add the distance between vertex position
        // and voxel center.
        Vec3 voxelCenter = voxelizer.getVoxelCenter(voxelIndex);
        boneDistance += voxelCenter.distanceTo(points[j]);

        // Normalize by bounding box extends (world space)
        boneDistance /= bbExtends;

        // Avoid division by zero
        if (boneDistance < epsilon)
          boneDistance = epsilon;

        // Compute the final weights
        Scalar divisor = ((1.0 - this.falloff) * boneDistance) + (this.falloff * pow(boneDistance, 2)); 
        Scalar weight = pow(1.0 / divisor, 2);

        // Set the vertex weight for this bone
        vertexWeights[j] = weight;

     }
  }
}

function ComputeGeodesicVoxelBindModifier.evaluate!(EvalContext context, io GeometrySet geomSet){
  AutoProfilingEvent p(FUNC);
  // TODO: Implement evaluation once steps are built for voxelization, distance computation and weighting computation.
}


