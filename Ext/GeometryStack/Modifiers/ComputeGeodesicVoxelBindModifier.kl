/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;
require RiggingToolbox;

//////////////////////////////////////
// Factory definition.
object ComputeGeodesicVoxelBindModifierFactory : GeometryOperatorFactory {
};

function GeometryOperator ComputeGeodesicVoxelBindModifierFactory.constructGeometryOperator(){
  ComputeGeodesicVoxelBindModifier geomOp();
  return geomOp;
}


//////////////////////////////////////
// ComputeGeodesicVoxelBindModifier

// Based roughly on http://www.delasa.net/data/sca2013_voxelization.pdf
object ComputeGeodesicVoxelBindModifier : BaseModifier {
  Scalar falloff; // user parameter between 0 to 1
};


function UInt32[String] ComputeGeodesicVoxelBindModifier.getAttributeInteractions(){
  UInt32 result[String];
  result['positions'] = AttrMode_Read;
  result['skinningData'] = AttrMode_Write;
  return result;
}

//////////////////////////////////////
// Voxelize

/// Borrowed from Voxelize preset node in FE 2.0
/// \internal
operator ComputeGeodesicVoxelBindModifier_VoxelizeTask<<<index>>>(io Vec4_i[][] hLine,
                                                                  PolygonMesh   mesh,
                                                                  Float32       cellSizeInv,
                                                                  UInt32        numRayi,
                                                                  Vec3          vDir,
                                                                  Vec3          vPosStart,
                                                                  Vec3          vPosStartAddi,
                                                                  Vec3          vPosStartAddj)
{
  const Float32 epsilon = 0.001;

  // begin spatial query.
  Ref<SpatialQuery> query = mesh.beginSpatialQuery();

  // split index into row/column.
  UInt32 rayj = index / numRayi;
  UInt32 rayi = index - rayj * numRayi;
    
  // calculate ray's starting position.
  Vec3 rayPos = vPosStart + rayi * vPosStartAddi + rayj * vPosStartAddj;

  // declare and init security counter (to avoid a possible infinite loop due to rounding errors).
  UInt32 security = 1;

  // ray cast.
  while (true)
  {
    // get the intersection.
    Ray ray(rayPos, vDir);
    GeometryLocation gloc = query.raycast(ray, true, 0, SCALAR_INFINITE);

    // no hit?
    if (!gloc.isValid())
      break;

    // get the position at gloc.
    Vec3 glocPos = polymesh.getPositionAtLocation(gloc);

    // set newLine's position from gloc and its length to 0.
    Vec4_i newLine;
    newLine.x = floor(glocPos.x * cellSizeInv);
    newLine.y = floor(glocPos.y * cellSizeInv);
    newLine.z = floor(glocPos.z * cellSizeInv);
    newLine.t = 0;

    // calculate ray's starting position for the second ray cast.
    rayPos = glocPos + epsilon * vDir;
    ray.set(rayPos, vDir);
    gloc = query.raycast(ray, true, 0, SCALAR_INFINITE);

    // no hit?
    if (!gloc.isValid())
    {
      // add newLine to hLine and break.
      hLine[index].push(newLine);
      break;
    }

    // get the position at gloc.
    glocPos = polymesh.getPositionAtLocation(gloc);
          
    // set newLine's final length (in cells).
    newLine.t =   (floor(glocPos.x * cellSizeInv) - newLine.x)
                + (floor(glocPos.y * cellSizeInv) - newLine.y)
                + (floor(glocPos.z * cellSizeInv) - newLine.z);

    // perform security check, calculate next ray's starting position and add newLine to hLine.
    if (newLine.t > 1)
    {
      security = 1;
      rayPos = glocPos + epsilon * vDir;
      hLine[index].push(newLine);
    }
    else
    {
      // is newLine identical with the last line in hLine?
      if (hLine[index].size() > 0 && newLine == hLine[index][hLine[index].size() - 1])
      {
        // increase the security and ignore newLine (i.e. don't add it to hLine).
        security++;
        rayPos = glocPos + epsilon * Float32(security) * vDir;
      }
      else
      {
        security = 1;
        rayPos = glocPos + epsilon * vDir;
        hLine[index].push(newLine);
      }
    }
  }

  // end spatial query.
  polymesh.endSpatialQuery(query);
}


/// Borrowed from Voxelize preset node in FE 2.0
function ComputeGeodesicVoxelBindModifier.voxelize(in PolygonMesh mesh,
                                                   Scalar detail, 
                                                   Integer projection, 
                                                   Integer acceleration, 
                                                   Boolean threading,
                                                   io Vec4_i hLine[][],
                                                   out Vec3 bbSize) 
{

  // check.
  if ( detail < DIVIDEPRECISION
      || mesh == null
      || mesh.polygonCount() <= 0
      || mesh.triangleCount() <= 0)
    return;

  // convert detail into cell size.
  Float32 cellSize    = 1.0 / detail;
  Float32 cellSizeInv = detail; // similar to (1.0 / cellSize)

  // get the bounding box of the mesh and snap its corners to the grid defined by cellSize.
  Vec3 bbMin;
  Vec3 bbMax;
  //Vec3 bbSize; 
  {
    // get the bounding box corners.
    LocalBoundingVolume bvol = mesh.getBoundingVolume();
    bbMin = bvol.bBoxGetMin();
    bbMax = bvol.bBoxGetMax();

    // snap bbmin to grid.
    bbMin  *= cellSizeInv;
    bbMin.x = floor(bbMin.x);
    bbMin.y = floor(bbMin.y);
    bbMin.z = floor(bbMin.z);
    bbMin  *= cellSize;

    // snap bbmax to grid.
    bbMax  *= cellSizeInv;
    bbMax.x = ceil(bbMax.x);
    bbMax.y = ceil(bbMax.y);
    bbMax.z = ceil(bbMax.z);
    bbMax  *= cellSize;
  
    // calculate size.
    bbSize = bbMax - bbMin;

    // bounding box no good?
    if (   bbSize.x <= 0
        || bbSize.y <= 0
        || bbSize.z <= 0)
      return;
  }
  
  // determine the plane for the ray casting.
  const Integer PLANE_XY = 1;
  const Integer PLANE_XZ = 2;
  const Integer PLANE_ZY = 3;
  Integer raycastPlane;
  switch (projection)
  {
    case PLANE_XY:
    case PLANE_XZ:
    case PLANE_ZY:
    {
      raycastPlane = projection;
      break;
    }
    default:
    {
      Float32 bbAreaXY = bbSize.x * bbSize.y;
      Float32 bbAreaXZ = bbSize.x * bbSize.z;
      Float32 bbAreaZY = bbSize.z * bbSize.y;
      if      (bbAreaXY <= bbAreaXZ && bbAreaXY <= bbAreaZY)  raycastPlane = PLANE_XY;
      else if (bbAreaXZ <= bbAreaXY && bbAreaXZ <= bbAreaZY)  raycastPlane = PLANE_XZ;
      else                                                    raycastPlane = PLANE_ZY;
      break;
    }            
  }
    
  // do it.
  Vec4_i hLine[][];  // h-lines (x, y, z is line's starting position, t is line's length, all units in cells).
  Vec3   vDir = 0;   // the vector used for raycasting, its length is equal cellSize.
  {
    // calculate the amount of rays in i and j and init the vectors that will be used when casting the rays.
    UInt32 numRayi;
    UInt32 numRayj;
    Vec3 vPosStart     = bbMin;
    Vec3 vPosStartAddi = 0;
    Vec3 vPosStartAddj = 0;
    switch (raycastPlane)
    {
      case PLANE_XY:
        numRayi = round(bbSize.x * cellSizeInv);
        numRayj = round(bbSize.y * cellSizeInv);
        vDir         .z = cellSize;
        vPosStartAddi.x = cellSize;
        vPosStartAddj.y = cellSize;
        vPosStart    .z = vPosStart.z - cellSize;
        break;
      case PLANE_XZ:
        numRayi = round(bbSize.x * cellSizeInv);
        numRayj = round(bbSize.z * cellSizeInv);
        vDir         .y = cellSize;
        vPosStartAddi.x = cellSize;
        vPosStart    .y = vPosStart.y - cellSize;
        vPosStartAddj.z = cellSize;
        break;
      default:
        numRayi = round(bbSize.z * cellSizeInv);
        numRayj = round(bbSize.y * cellSizeInv);
        vDir         .x = cellSize;
        vPosStart    .x = vPosStart.x - cellSize;
        vPosStartAddj.y = cellSize;
        vPosStartAddi.z = cellSize;
        break;
    }
    vPosStart += 0.5 * (vPosStartAddi + vPosStartAddj);

    // init/set hLine[][].
    hLine.resize(numRayi * numRayj);

    // prepare mesh for spatial queries.
    GenericValueContainer options = GenericValueContainer();
    if (acceleration == 0)  PrepareForSpatialQueries_setOctree    (options);
    else                    PrepareForSpatialQueries_setSparseGrid(options);
    mesh.prepareForSpatialQueries(numRayi * numRayj, options);
    
    // fill hLine.
    if (threading || (!threading && hLine.size() < 32))
    {
      // singlethreaded.
      for (UInt32 i=0;i<hLine.size();i++)
        ComputeGeodesicVoxelBindModifier_VoxelizeTask(i, hLine, mesh, cellSizeInv, numRayi, vDir, vPosStart, vPosStartAddi, vPosStartAddj);
    }
    else
    {
      // multithreaded.
      ComputeGeodesicVoxelBindModifier_VoxelizeTask<<<hLine.size()>>>(hLine, mesh, cellSizeInv, numRayi, vDir, vPosStart, vPosStartAddi, vPosStartAddj);
    }
  }
}

//////////////////////////////////////
// Compute Bone Voxel Distances

// Get the voxel space index for a world space position
/// \internal
inline Vec3_i ComputeGeodesicVoxelBindModifier.getVoxelIndex(Vec3 pt, Scalar cellSizeInv)
{
  return Vec3_i( floor(pt.x * cellSizeInv), 
                 floor(pt.y * cellSizeInv),
                 floor(pt.z * cellSizeInv) );
}

// Get the voxel's center position in world space from a voxel space index
/// \internal
inline Vec3 ComputeGeodesicVoxelBindModifier.getVoxelCenter(Vec3_i voxel_index, Scalar cellSize)
{
  return Vec3( (pt.x * cellSize) + 0.5 * cellSize, 
               (pt.y * cellSize) + 0.5 * cellSize,
               (pt.z * cellSize) + 0.5 * cellSize);
}

// Compute the distance between each bones' position towards all Voxel centers
// with a form of Dijkstra's algorithm
function ComputeGeodesicVoxelBindModifier.computeDistances(Vec4_i hLines[][],
                                                           Vec3 lineDirection,
                                                           Mat44 bones[], 
                                                           Scalar cellSizeInv, 
                                                           out Scalar voxelBoneDistances[][Vec3_i])
{

  // Voxel conversion from hLines to dictionary based
  // (we use dictionary to have sparse entries and perform quick hash lookup)
  Boolean voxels[Vec3_i];
  Vec4_i hLine;
  Scalar lineLength;
  Vec3 lineStart;
  Scalar numSteps;
  Vec3 voxelPos;
  Vec3_i voxelIndex;
  Scalar cellSize = 1 / cellSizeInv;

  for(Integer i=0; i<hLines.size(); i++)
  {
    for(Integer j=0; j<hLines[i].size(); j++)
    {
        hLine = hLines[i][j];
        lineStart = Vec3(hLine.x, hLine.y, hLine.z);
        lineLength = hLine.t;

        // Define all voxels for this line.
        numSteps = lineLength / cellSize;
        for(Integer x=0; x<numSteps; x++)
        {
            voxelPos = lineStart + (x * cellSize);
            voxelIndex = this.getVoxelIndex(voxelPos, cellSize);
            voxels[voxelIndex] = true;
        }
    }
  }

  // Predefined set of neighbour offsets used to easily
  // iterate towards each neighbour voxel
  Vec3_i neighbours[6];
  neighbours[0] = Vec3_i(-1, 0, 0);
  neighbours[1] = Vec3_i(1, 0, 0);
  neighbours[2] = Vec3_i(0, -1, 0);
  neighbours[3] = Vec3_i(0, 1, 0);
  neighbours[4] = Vec3_i(0, 0, -1);
  neighbours[5] = Vec3_i(0, 0, 1);

  voxelBoneDistances.resize(bones.size());

  for(Size i=0; i<bones.size(); i++)
  {
    Scalar voxelDistances[Vec3_i] = voxelBoneDistances[i];
    voxelDistances.clear();

    // Initialize voxel distance values to infinite
    for(key in voxels)
    {
      voxelDistances[key] = SCALAR_INFINITE;
    }

    // Identify the voxel intersecting the bone (skeleton) and
    // set this distance to zero
    Vec3 bonePos = bones[i].translation();
    Vec3_i boneVoxelIndex = this.getVoxelIndex(bonePos, cellSizeInv);
    voxelDistances[boneVoxelIndex] = 0; // zero distance for this voxel

    // Iterate all neighbours and increase voxel distance
    // TODO: Setup a Queue datatype to optimize the First-in-first-out
    QueueVec3_i queue;
    queue.enqueue(boneVoxelIndex);
    Integer dist;
    
    // Compute geodesic distance using a form of dijkstra's algorithm
    while(!queue.isEmpty())
    {
      Vec3_i currentIndex = queue.front();
      queue.dequeue(); // pop from queue

      for(Size x=0; x<neighbours.size(); x++)
      {
        Vec3_i neighbourIndex = currentIndex + neighbours[x];
        if (voxels.has(neighbourIndex)) // Check if neighbour exists
        {  
            // Neighbour distance is plus one in voxel space
            dist = voxelBoneDistances[currentIndex] + 1;

            // If the stored distance for the bone is higher (eg. infinite) 
            // currently than the computed weight it means we still have to traverse
            // since it's closer than expected, so set it and add it to the queue
            if (voxelBoneDistances[neighbourIndex] > dist)
            {
              voxelDistances[neighbourIndex] = dist;
              queue.enqueue(neighbourIndex);
            }
        }
      }
    }
  }
}


//////////////////////////////////////
// Compute weights based on the voxelBoneDistances calculated in ComputeGeodesicVoxelBind.computeDistances()
function ComputeGeodesicVoxelBindModifier.computeWeights(in PolygonMesh mesh,
                                                 in Scalar cellSizeInv, 
                                                 in Scalar bbSize,
                                                 in Scalar voxelBoneDistances[][Vec3_i],
                                                 out Scalar boneVertexWeights[][]
                                                   )
{

  Scalar epsilon = 0.00001;

  // Resize to number of bones
  boneVertexWeights.resize(voxelBoneDistances.size());

  // Get mesh vertices
  Size pointCount = mesh.pointCount();
  Ref<GeometryAttributes> attributes = mesh.getAttributes();
  Vec3Attribute positionsAttribute = attributes.positionsAttribute;
  Vec3 points = positionsAttribute.values;

  Scalar cellSize = 1 / cellSizeInv;
  Scalar bbExtends = bbSize.x * bbSize.y * bbSize.z;

  // For each bone go through all vertices, find their voxel and set the
  // weights using the calculated geodesic voxelBoneDistances
  for(Size boneIndex = 0; boneIndex<voxelBoneDistances.size(); boneIndex++)
  {
     Scalar vertexWeights[] = boneVertexWeights[boneIndex];
     vertexWeights.resize(pointCount);
     
     for(Size j=0; j<pointCount; j++)
     {
        // Get voxel for point
        Vec3_i voxelIndex = this.getVoxelIndex(points[j], cellSizeInv);

        // Get the calculated distance for the bone in the voxel (in voxel space)
        Scalar boneDistance = voxelBoneDistances[boneIndex][j];

        // Convert to world space size from voxel space
        boneDistance *= cellSize;

        // To compensate for the voxel gridâ€™s coarseness, and the fact that multiple vertices
        // may fall in the same voxel, we add the distance between vertex position
        // and voxel center.
        Vec3 voxelCenter = this.getVoxelCenter(voxelIndex, cellSizeInv);
        boneDistance += voxelCenter.distanceTo(points[j]);

        // Normalize by bounding box extends
        boneDistance /= bbExtends;

        // Avoid division by zero
        if (boneDistance < epsilon)
          boneDistance = epsilon;

        // Compute the final weights
        Scalar divisor = ((1 - falloff) * boneDistance) + (falloff * pow(boneDistance, 2)); 
        Scalar weight = pow(1 / divisor, 2);

        // Set the vertex weight for this bone
        vertexWeights[j] = weight;

     }
  }
}

function ComputeGeodesicVoxelBindModifier.evaluate!(EvalContext context, io GeometrySet geomSet){
  AutoProfilingEvent p(FUNC);
  // TODO: Implement evaluation once steps are built for voxelization, distance computation and weighting computation.
}


