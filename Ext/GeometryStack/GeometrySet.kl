/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Geometry;

object GeometrySet {
  Geometry geometries[];

  UInt32 attributeGenerations[String];

  CachePoint cachePoints[];
  UInt32 stackPoint;

  ///Container for holding various user data, such as the Skeleton.
  Object metaData[String];
  UInt32 version;
};

/// returns the size of the contained value array
inline Size GeometrySet.size() {
  return this.geometries.size();
}

/// resizes the contained value array
inline GeometrySet.resize!(Size newSize) {
  this.geometries.resize(newSize);
  this.version++;
}

/// returns a geometry the by index
inline Geometry GeometrySet.get(Index index) {
  return this.geometries[index];
}

/// sets a geometry by index
inline GeometrySet.set!(Index index, Geometry value) {
  this.geometries[index] = value;
  this.version++;
}

/// adds a geometry
inline GeometrySet.add!(Geometry value) {
  this.geometries.push(value);
  this.version++;
}


inline UInt32 GeometrySet.getAttributeGeneration(String attributeName) {
  return this.attributeGenerations.get(attributeName, 0);
}

inline GeometrySet.setAttributeGeneration!(String attributeName, UInt32 gen) {
  this.attributeGenerations[attributeName] = gen;
}

inline GeometrySet.incrementAttributeGeneration!(String attributeName) {
  UInt32 gen = this.attributeGenerations.get(attributeName, 0);
  this.attributeGenerations[attributeName] = gen+1;
}


/// returns true if the geometry set owns a meta data under the given key
function Boolean GeometrySet.hasMetaData( String name ) {
  return this.metaData.has( name );
}

/// gets a single object out of the container or null if it doesn't exist
function Ref<Object> GeometrySet.getMetaData( String name ) {
  return this.metaData.get( name, null );
}

/// sets a single object in the metadata
function GeometrySet.setMetaData!( String name, Object value ) {
  this.metaData[name] = value;
  this.version++;
}
/// sets a single object in the metadata
function UInt32 GeometrySet.getVersion() {
  return this.version;
}

/// Generates a Description string of this geom set.
/// \param indent The indentation to use when generating the string. 
function String GeometrySet.getDesc(String indent, Boolean includeGeometryTolopology) {
  String desc;
  desc += indent + "{ \n";
  desc += indent + "  geometries:[ \n";
  for(Integer i=0; i<this.size; i++){
    desc += indent + "    " + getGeomDebugName(this.get(i)) + ":{\n";
    
    if(includeGeometryTolopology){
      desc += indent + "      " + this.get(i).getDesc(true, true);
    }
    desc += indent + "    },\n";
  }
  desc += indent + "  ]\n";

  desc += indent + "  attributeGenerations:{ \n";
  for(key, value in this.attributeGenerations){
    desc += indent+'    ' + key + ":" + value + ",\n";
  }
  desc += indent + "  },\n";
  desc += indent + "}";
  return desc;
}

/// Generates a Description string of this stack.
function String GeometrySet.getDesc() {
  return this.getDesc("", false);
}

/// Adds a new cache point using the provided operator.
function GeometrySet.addCachePoint!(GeometryOperator op) {
  // Generate cache points for each operator.
  // Note: currently we are creating cache points for every operator
  // but this is excessive. Many operators may not need to be cached.
  Generator generator = op;
  CachePoint cachePoint = null;
  if(generator)
    cachePoint = GeometryCache();
  else
    cachePoint = GeometryAttributeCache(op);
  this.cachePoints.push(cachePoint);
}

/// Updates the cache to the point specified.
function GeometrySet.updateCache!(UInt32 stackPoint, GeometryOperator op) {
  AutoProfilingEvent p(FUNC+":"+stackPoint);

  // The data previous to this point has been re-computed. 
  // The cache must be updated.
  this.cachePoints[stackPoint].update(this.geometries);
  this.stackPoint = stackPoint;
}

function GeometrySet.rewind!(UInt32 stackPoint) {
  AutoProfilingEvent p(FUNC+":"+stackPoint);

  if(stackPoint >= this.cachePoints.size)
    return;

  for(UInt32 i=this.stackPoint-1; i>=stackPoint; i--)
    this.cachePoints[i].restore(this.geometries);
  this.stackPoint = stackPoint;
}

/// Returns a new set of cloned geometires at the specifies point in the stack.
function Geometry[] GeometrySet.getGeometryClonesAtVersion(UInt32 stackPoint) {
  // clone the geometries at the state they are now, and then rewind them back to the state requested.
  Geometry geoms[];
  geoms.resize(this.geometries.size);
  for(UInt32 i=0; i<this.geometries.size; i++)
    geoms[i] = cloneGeom(this.geometries[i]);

  for(UInt32 i=this.stackPoint-1; i>=stackPoint; i--)
    this.cachePoints[i].restore(geoms);
  return geoms;
}

function GeometrySet.convertToCPU!() {
  for(UInt32 i=0; i<this.geometries.size; i++){
    Ref<PolygonMesh> mesh = this.geometries[i];
    if(mesh != null && mesh.getMemType() != 0)
      mesh.convertToCPU();

    Ref<GeometryAttributes> attributes = this.geometries[i].getAttributes();
    // Iterate over the attributes, moving them back ot the CPU if necessary.
    GeometryAttributesIterator iter = attributes.getAttributesIterator();
    Ref<GeometryAttribute> attribute = null;
    while( attribute = iter.getNext() ){
      if(attribute.getElementsMemType() != 0)
        attribute.convertToCPU();
    }
  }
}

