/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;


object GeometryAttributeCache : CachePoint {
  // Temp: Used in debugging and unit testing.
  Boolean disabled;
  Boolean valid;

  String cachedAttributesNames[];
  GeometryAttribute cachedAttributes[][];
  UInt32 attributeVersions[][];
};

function GeometryAttributeCache(String cachedAttributesNames[]) {
  this.setCachedAttributeNames(cachedAttributesNames);
}


function GeometryAttributeCache.disable!() {
  this.disabled = true;
}

function GeometryAttributeCache.enable!() {
  this.disabled = false;
}

function GeometryAttributeCache.invalidate!() {
  this.valid = false;
}

function Boolean GeometryAttributeCache.isValid() {
  return this.valid;
}

function GeometryAttributeCache.setCachedAttributeNames!(String cachedAttributesNames[]) {
  this.cachedAttributesNames = cachedAttributesNames.clone();
}

function GeometryAttributeCache.init!(Geometry geometries[]) {
  if(this.disabled)
    return;
  AutoProfilingEvent p(FUNC);
  this.cachedAttributes.resize(geometries.size);
  this.attributeVersions.resize(geometries.size);
  for(Integer i=0; i<geometries.size; i++){
    Ref<GeometryAttributes> attributes = geometries[i].getAttributes();
    this.cachedAttributes[i].resize(this.cachedAttributesNames.size);
    this.attributeVersions[i].resize(this.cachedAttributesNames.size);
    for(Integer j=0; j<this.cachedAttributes.size; j++){
      Ref<GeometryAttribute> attr = attributes.getAttribute(this.cachedAttributesNames[i]);
      if(attr){
        this.cachedAttributes[i][j] = cloneAttribute(attr);
        this.attributeVersions[i][j] = attr.getVersion();
      }
      else{
        // report("Warning: geometry does not have required attribute ");
        report("Warning in GeometryAttributeCache.init: Geometry " +getGeomDebugName(geometries[i])+ " at index :"+i+" does not have the following attribute:" + this.cachedAttributesNames[i]);// Maybe the deformer will generate it. 
      }
    }
  }
  this.valid = true;
}

/// Restores the geometry attributes to the state found in the cache.
function GeometryAttributeCache.restore(io Geometry geometries[]){
  if(this.disabled)
    return;
  AutoProfilingEvent p(FUNC);
  for(Integer i=0; i<geometries.size; i++){
    Ref<GeometryAttributes> attributes = geometries[i].getAttributes();
    for(Integer j=0; j<this.cachedAttributesNames.size; j++){
      Ref<GeometryAttribute> attr = attributes.getAttribute(this.cachedAttributesNames[j]);
      if(this.cachedAttributes[i][j] != null){
        if(this.attributeVersions[i][j] != attr.getVersion()){
          Ref<Object> cachedAttr = this.cachedAttributes[i][j];
          attr.copyFrom( cachedAttr );
        }
      }
      else{
        // The attribute did not exist before. 
        // remove the attribute?
      }
    }
  }
}


function GeometryAttributeCache.update!(io Geometry geometries[]) {
  if(this.valid)
    this.init(geometries);
  else
    this.restore(geometries);
}


