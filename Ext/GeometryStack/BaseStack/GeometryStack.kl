/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;


object GeometryStack : Listener {
	Geometry geometries[];
	GeometryOperator geomOperators[];
	CachePoint cachePoints[];
	UInt32 dirtyPoint;


	// e.g. If a deformer modifies positions, and the subsequent deformer
	// ultilizes normals, and there is a dependeny from normals to positions
	// then normals have to be automatically recomputed before the next deformer is run. 
	String implicitDependencies[String][];
};

function GeometryStack() {
	this.init();
}


function GeometryStack.init!() {
	this.addAttributeDependency('normals', 'positions');
	this.addAttributeDependency('tangents', 'positions');
	this.addAttributeDependency('tangents', 'normals');
}

function GeometryStack.addAttributeDependency!(String from, String to) {
	if(!this.implicitDependencies.has(from)){
		String emptyArray[];
		this.implicitDependencies[from] = emptyArray;
	}
	this.implicitDependencies[from].push(to);
}

function GeometryStack.addGeometryOperator!(GeometryOperator op) {
	this.geomOperators.push(op);
}

// Prepare the cache points.
function GeometryStack.initCachePoints!() {
	this.cachePoints.resize(this.geomOperators.size);
	for(Integer i=0; i<this.geomOperators.size; i++){
		Generator generator = this.geomOperators[i];
		if(generator){
			if(generator.cacheResults())
				this.cachePoints[i] = GeometryCache();
		}
		else{
			String modifiedAttributes[] = this.geomOperators[i].getModifiedAttributes();
			if(modifiedAttributes.size > 0)
				this.cachePoints[i] = GeometryAttributeCache(modifiedAttributes);
		}
		generator = this.geomOperators[i];
	}
}

function GeometryStack.disableCachePoint!(UInt32 index) {
	if(this.cachePoints[index] != null)
		this.cachePoints[index].disable();
}

function GeometryStack.enableCachePoint!(UInt32 index) {
	if(this.cachePoints[index] != null)
		this.cachePoints[index].enable();
}

function GeometryStack.notify!(Notifier notifier, String type, String data) {
	switch(type){
	case 'changed':
		for(Integer i=0; i<this.geomOperators.size; i++){
			Notifier op = this.geomOperators[i];
			if(op === notifier){
				this.dirtyPoint = i;
				break;
			}
		}
		break;
	}
}

// Pull-model evaluation. Evaluation can be recursive when multiple stacks are used in conjunction.
// e.g. 
//  [ LoadAlembic, SkinningDeformer ]
//                                  |
//             [ LoadAlembic, WrapDeformer ] ->
function Geometry[] GeometryStack.evaluate!(EvalContext context) {
	this.dirtyPoint = 0;// force evlauation all the time.
	if(this.dirtyPoint < this.geomOperators.size){
		for(Integer i=this.dirtyPoint; i<this.geomOperators.size; i++){

			// Now check the geometries if they have the attributes required by the next operation.
			Boolean debug = true;
			if(debug){
				String requiredAttributes[] = this.geomOperators[i].getRequiredAttributes();
				for(Integer k=0; k<this.geometries.size; k++){
					String missingAttributes[];
					for(Integer j=0; j<requiredAttributes.size; j++){
						Ref<GeometryAttributes> attributes = this.geometries[k].getAttributes();
						if(!attributes.has(requiredAttributes[j]))
							missingAttributes.push(requiredAttributes[j]);
					}
					if(missingAttributes.size > 0)
						setError('Geometry missing required attributes:' + missingAttributes);
				}
			}

			CachePoint cachePoint = this.cachePoints[i];
			if(cachePoint != null && cachePoint.isValid())
				cachePoint.restore(this.geometries);
			else{
				this.geomOperators[i].evaluate(context, this.geometries);
				if(cachePoint != null)
					cachePoint.init(this.geometries);
			}
			this.dirtyPoint++;
		}
	}
	return this.geometries;
}



function String GeometryStack.saveJSON(){
	String json;
	return json;
}

function GeometryStack.loadJSON!(String json){
  
}
