/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;

object BaseModifier;

object GeometryAttributeCache : CachePoint, Listener  {
  BaseModifier modifier;
  Boolean moveDataToGPU;
  String attributesNames[];
  UInt32 attributesInteractions[];
  GeometryAttribute cachedAttributes[][];
};

function GeometryAttributeCache(BaseModifier modifier) {
  // Add a listener to know when we should update the cached attribute interaction types. 
  this.modifier = modifier;
  Listener listener = this; // No implicit casting in KL from objects to interfaces.
  this.modifier.addListener(listener);
  this.updateCachedAttributeNames();
}

// Recieves a notification from one of the notifiers. 
// This will always be the geometry operator.
function GeometryAttributeCache.notify!(Notifier notifier, String type, String data) {
  this.updateCachedAttributeNames();
}

  
function GeometryAttributeCache.updateCachedAttributeNames!() {
  UInt32 deps[String] = this.modifier.getAttributeInteractions();
  this.attributesNames.resize(0);
  this.attributesInteractions.resize(0);
  for(key, value in deps){
    this.attributesNames.push(key);
    this.attributesInteractions.push(value);
  }
  this.moveDataToGPU = this.modifier.useGPU();
}

/// Restores the geometry attributes to the state found in the cache.
function GeometryAttributeCache.update!(Geometry geometries[]) {
  AutoProfilingEvent p(FUNC+":" + this.modifier.type() +":"+this.attributesNames);
  report(FUNC+ ":" + this.modifier.type()+":"+this.attributesNames);

  UInt32 numGeoms = geometries.size;
  UInt32 numcachedAttrs = this.attributesNames.size;
  this.cachedAttributes.resize(numGeoms);

  for(Integer i=0; i<numGeoms; i++){
    Geometry geo = geometries[i];
    PolygonMesh mesh = geo;
    if(mesh != null){
      report("mesh.getMemType():"+mesh.getMemType() + ":" + this.moveDataToGPU);
      if(this.moveDataToGPU){
        if(mesh.getMemType() == 0)
          mesh.convertToGPU();
      }
      else{
        if(mesh.getMemType() != 0)
          mesh.convertToCPU();
      }
    }

    Ref<GeometryAttributes> attributes = geometries[i].getAttributes();
    this.cachedAttributes[i].resize(numcachedAttrs);
    for(Integer j=0; j<numcachedAttrs; j++){
      String attrName = this.attributesNames[j];
      report("update:"+attrName);
      Ref<GeometryAttribute> attr = attributes.getAttribute(attrName);
      if(!attr){
        // Check if the attribute will be read by the modifier. If so, then throw an exception.
        if(this.attributesInteractions[j] != AttrMode_Write)
          throw("Error: Missing Attribute:" + attrName + ". Required for modifier:" + this.modifier.type());
        // Else, the modifier will generate the attribute.
        continue;
      }

      // If the operator requires the data to be on the GPU, and the data is currently on the CPU,
      // move it to the GPU. If the operator requires the data on the CPU, but it is on the GPU,
      // move it back.
      if(this.moveDataToGPU){
        if(attr.getElementsMemType() == 0)
          attr.convertToGPU();
      }
      else{
        if(attr.getElementsMemType() != 0){
          report("WARNING: Moving data back to the CPU is quite costly and should be avoided.");
          attr.convertToCPU();
        }
      }
      if(this.attributesInteractions[j] == AttrMode_ReadWrite){
        // Only read/write attributes must be cached before the modifier changes the value.
        if(this.cachedAttributes[i][j] == null || this.cachedAttributes[i][j].type() != attr.type()){
          this.cachedAttributes[i][j] = cloneAttribute(attr);
        }
        else{
          this.cachedAttributes[i][j].copyFrom(attr);
        }
      }
    }
  }
}


/// Restores the geometry attributes to the state found in the cache.
function GeometryAttributeCache.restore(io Geometry geometries[]) {
  AutoProfilingEvent p(FUNC+ ":" + this.modifier.type()+":"+this.attributesNames);
  report(FUNC+ ":" + this.modifier.type()+":"+this.attributesNames);

  for(Integer i=0; i<geometries.size; i++){
    Ref<GeometryAttributes> attributes = geometries[i].getAttributes();
    for(Integer j=0; j<this.attributesNames.size; j++){
      if(this.attributesInteractions[j] == AttrMode_ReadWrite){
        String attrName = this.attributesNames[j];
        report("restore:"+attrName);
        Ref<GeometryAttribute> attr = attributes.getAttribute(attrName);

        // Restore the attribute to its previous value.
        Ref<Object> cachedAttr = this.cachedAttributes[i][j];
        attr.copyFrom( cachedAttr );
      }
    }
  }
}