/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;

object BaseModifier;

object GeometryAttributeCache : CachePoint, Listener  {
  BaseModifier modifier;
  Boolean moveAttributeDataToGPU;
  String attributesNames[];
  UInt32 attributesInteractions[];
  GeometryAttribute cachedAttributes[][];
};

function GeometryAttributeCache(BaseModifier modifier) {
  // Add a listener to know when we should update the cached attribute interaction types. 
  this.modifier = modifier;
  Listener listener = this; // No implicit casting in KL from objects to interfaces.
  this.modifier.addListener(listener);
  this.updateCachedAttributeNames();
}

// Recieves a notification from one of the notifiers. 
// This will always be the geometry operator.
function GeometryAttributeCache.notify!(Notifier notifier, String type, String data) {
  this.updateCachedAttributeNames();
}

  
function GeometryAttributeCache.updateCachedAttributeNames!() {
  UInt32 deps[String] = this.modifier.getAttributeInteractions();
  this.attributesNames.resize(0);
  this.attributesInteractions.resize(0);
  for(key, value in deps){
    this.attributesNames.push(key);
    this.attributesInteractions.push(value);
  }
  this.moveAttributeDataToGPU = this.modifier.useGPU();
}

/// Restores the geometry attributes to the state found in the cache.
function GeometryAttributeCache.update!(Geometry geometries[]) {
  AutoProfilingEvent p(FUNC+":"+this.attributesNames);

  UInt32 numGeoms = geometries.size;
  UInt32 numcachedAttrs = this.attributesNames.size;
  this.cachedAttributes.resize(numGeoms);

  for(Integer i=0; i<numGeoms; i++){
    Ref<GeometryAttributes> attributes = geometries[i].getAttributes();
    this.cachedAttributes[i].resize(numcachedAttrs);
    for(Integer j=0; j<numcachedAttrs; j++){
      String attrName = this.attributesNames[j];
      Ref<GeometryAttribute> attr = attributes.getAttribute(attrName);
      // Update the cached attribute to the new value.
      AutoProfilingEvent pUpdate("Update:"+attrName);

      // If the operator requires the data to be on the GPU, and the data is currently ont he CPU,
      // move it to the GPU and then generate the cached attribute.
      if(this.moveAttributeDataToGPU && attr.getElementsMemType() == 0){
        attr.convertToGPU();
      }
      if(this.attributesInteractions[j] == AttrMode_ReadWrite){
        if(this.cachedAttributes[i][j] == null || this.cachedAttributes[i][j].type() != attr.type()){
          this.cachedAttributes[i][j] = cloneAttribute(attr);
        }
        else{
          this.cachedAttributes[i][j].copyFrom(attr);
        }
      }
    }
  }
}


/// Restores the geometry attributes to the state found in the cache.
function GeometryAttributeCache.restore(io Geometry geometries[]) {
  AutoProfilingEvent p(FUNC+":"+this.attributesNames);
  report(FUNC+":"+this.attributesNames);

  for(Integer i=0; i<geometries.size; i++){
    Ref<GeometryAttributes> attributes = geometries[i].getAttributes();
    for(Integer j=0; j<this.attributesNames.size; j++){
      if(this.attributesInteractions[j] == AttrMode_ReadWrite){
        String attrName = this.attributesNames[j];
        Ref<GeometryAttribute> attr = attributes.getAttribute(attrName);

        // Restore the attribute to its previous value.
        AutoProfilingEvent pRestore("Restore:"+attrName);

        Ref<Object> cachedAttr = this.cachedAttributes[i][j];
        attr.copyFrom( cachedAttr );
      }
    }
  }
}