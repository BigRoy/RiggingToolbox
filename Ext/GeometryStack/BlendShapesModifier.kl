/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;

struct BlendShapesModifier_Target {
  UInt32 indices[];
  Vec3 deltas[];
};

/// The Blend Shapes modifier stores a sparce data set of offsets. 
object BlendShapesModifier : BaseModifier {
  Vec3 referencePositions[][];
  BlendShapesModifier_Target targets[][];
  Scalar threshold;
};


function BlendShapesModifier(){
  this.threshold = 0.001;
}



//////////////////////////////////////
//

/// A struct for collecting points during surface painting.
/// \internal
struct BlendShapesModifier_collectGeomPointsSharedData {
  Vec3 positions[];
  Vec3 refpositions[];
  Scalar threshold;
};


/// A struct for collecting points during surface painting.
/// \internal
struct BlendShapesModifier_collectMeshPointsSharedData {
  PolygonMesh mesh;
  Vec3 refpositions[];
  Scalar threshold;
};

/// A struct for collecting points during surface painting.
/// \internal
struct CollectPointsMapOutput {
  Boolean collected;
  Integer index;
  Vec3 delta;
};


/// An operator for collecting points during surface painting.
/// \internal
operator blendShapesModifier_collectGeomPointsProduce(io CollectPointsMapOutput result, Index index, Size count, BlendShapesModifier_collectMeshPointsSharedData sharedData) {
  Vec3 pos = sharedData.positions[index];
  Vec3 delta = pos - sharedData.refpositions[index];
  if(delta.getLength() < sharedData.threshold){
    result.collected = true;
    result.index = index;
    result.delta = delta;
  }
}

/// An operator for collecting points during surface painting.
/// \internal
operator blendShapesModifier_collectMeshPointsProduce(io CollectPointsMapOutput result, Index index, Size count, BlendShapesModifier_collectMeshPointsSharedData sharedData) {
  Vec3 pos = sharedData.mesh.getPointPosition(index);
  Vec3 delta = pos - sharedData.refpositions[index];
  if(delta.getLength() < sharedData.threshold){
    result.collected = true;
    result.index = index;
    result.delta = delta;
  }
}


/// An operator for collecting points during surface painting.
/// \internal
operator blendShapesModifier_collectPointsReduce(CollectPointsMapOutput input, io BlendShapesModifier_Target output, Index index, Size count) {
  if(input.collected){
    output.indices.push(input.index);
    output.deltas.push(input.delta);
  }
}


function BlendShapesModifier.addTarget(UInt32 geomIndex, Geometry targetGeometry){
  UInt32 numTargets = this.targets[geomIndex];
  if(this.targets[geomIndex].size < numTargets+1){
    for(UInt32 i=0; i<this.targets.size; i++)
      this.targets[i].resize(numTargets+1);
  }
  UInt32 targetIndex = numTargets;

  PolygonMesh targetMesh = targetGeometry;
  if(!targetMesh){

    Ref<GeometryAttributes> attributes = geomSet.get(index).getAttributes();
    Vec3Attribute positionsAttribute = attributes.positionsAttribute;

    BlendShapesModifier_collectGeomPointsSharedData sharedData;
    sharedData.positions = positionsAttribute.values;
    sharedData.refpositions = this.referencePositions[geomIndex];
    sharedData.threshold = this.threshold;

    ValueProducer<BlendShapesModifier_Target> reducer = createReduce( 
      createArrayGenerator(
        createConstValue( attributes.size() ),
        blendShapesModifier_collectMeshPointsProduce,
        createConstValue( sharedData )
      ),
      blendShapesModifier_collectPointsReduce
    );
    this.targets[geomIndex][targetIndex] = reducer.produce();
  }
  else{
    BlendShapesModifier_collectMeshPointsSharedData sharedData;
    sharedData.mesh = targetMesh;
    sharedData.refpositions = this.referencePositions[geomIndex];
    sharedData.threshold = this.threshold;

    ValueProducer<BlendShapesModifier_Target> reducer = createReduce( 
      createArrayGenerator(
        createConstValue( targetMesh.pointCount() ),
        blendShapesModifier_collectMeshPointsProduce,
        createConstValue( sharedData )
      ),
      blendShapesModifier_collectPointsReduce
    );
    this.targets[geomIndex][targetIndex] = reducer.produce();
  }
}


operator BlendShapesModifier_applyGeomDeltas<<<index>>>(
  io Vec3 positions[],
  BlendShapesModifier_Target target
){
  positions[target.indices[index]] += target.deltas[index];
}

operator BlendShapesModifier_applyMeshDeltas<<<index>>>(
  io PolygonMesh mesh,
  BlendShapesModifier_Target target,
){
  Vec3 pos = mesh.getPointPosition(target.indices[index]);
  mesh.setPointPosition(target.indices[index], pos + target.deltas[index]);
}


operator deformGeometries<<<index>>>(
  io GeometrySet geomSet,
  UInt32ArrayAllocator indices,
  Vec3 deltas[]
){
  Geometry geom = geomSet.get(index);
  PolygonMesh mesh = geom;
  if(!mesh){
    Ref<GeometryAttributes> attributes = geomSet.get(index).getAttributes();
    Vec3Attribute positionsAttribute = attributes.positionsAttribute;
    BlendShapesModifier_applyGeomDeltas<<<attributes.size()>>>(
      positionsAttribute.values,
      this.targets[index]
    );
    positionsAttribute.incrementVersion();
  }
  else{
    BlendShapesModifier_applyGeomDeltas<<<mesh.pointCount()>>>(
      mesh,
      this.targets[index]
    );
    mesh.incrementPointPositionsVersion();
  }
  return true;
}

function BlendShapesModifier.evaluate(EvalContext context, io GeometrySet geomSet){
  deformGeometries<<<geomSet.size()>>>(geomSet, skinningPosAndNormMatrices);
}


function BlendShapesModifier.save(){
  
}

function BlendShapesModifier.load(){
  
}
