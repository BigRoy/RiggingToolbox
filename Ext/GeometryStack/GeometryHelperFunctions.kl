/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;


function Geometry cloneGeom(Geometry geometry) {
  // Note: we need clone to be part of the Geometry interface. 
  PolygonMesh mesh = geometry;
  if(mesh)
    return mesh.clone();
  else{
    Lines lines = geometry;
    if(lines)
      return lines.clone();
    else{
      Points points = geometry;
      if(points)
        return points.clone();
    }
  }
  throw("Invalid Geometry type:" + geometry.type());
}


function copyFrom(io Geometry geometry, Geometry srcGeometry) {
  // Note: we need copyFromGeometry to be part of the Geometry interface. 
  PolygonMesh mesh = geometry;
  if(mesh){
    PolygonMesh src = srcGeometry;
    if(src)
      mesh.copy(src);
  }
  else{
    Lines lines = geometry;
    if(lines){
      Lines src = srcGeometry;
      if(src)
        lines.copy(src);
    }
    else{
      Points points = geometry;
      if(points){
        Points src = srcGeometry;
        if(src)
          points.copy(src);
      }
      else{
        throw("Invalid Geometry type:" + geometry.type());
      }
    }
  }
}

function UInt32 getGeomVersion(Geometry geometry) {
  // Note: we need 'getVersion' to be part of the Geometry interface. 
  PolygonMesh mesh = geometry;
  if(mesh)
    return mesh.version;
  else{
    Lines lines = geometry;
    if(lines)
      return lines.version;
    else{
      Points points = geometry;
      if(points)
        return points.version;
    }
  }
  throw("Invalid Geometry type:" + geometry.type());
}




function ThreadsafeMetaDataContainer getGeomMetaData(Geometry geometry) {
  // Note: we need 'getVersion' to be part of the Geometry interface. 
  PolygonMesh mesh = geometry;
  if(mesh)
    return mesh.metaData;
  else{
    Lines lines = geometry;
    if(lines)
      return lines.metaData;
    else{
      Points points = geometry;
      if(points)
        return points.metaData;
    }
  }
  throw("Invalid Geometry type:" + geometry.type());
}



function String getGeomDebugName(Geometry geometry) {
  // Note: we need 'getVersion' to be part of the Geometry interface. 
  PolygonMesh mesh = geometry;
  if(mesh)
    return mesh.debugName;
  else{
    Lines lines = geometry;
    if(lines)
      return lines.debugName;
    else{
      Points points = geometry;
      if(points)
        return points.debugName;
    }
  }
  throw("Invalid Geometry type:" + geometry.type());
}



function GeometryAttribute cloneAttribute(GeometryAttribute attr) {
  // Note: we need clone to be part of the Geometry interface. 
  Ref<Object> src = attr;
  switch(attr.type()){
    case ColorAttribute:{
      ColorAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case IntegerAttribute:{
      IntegerAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case Mat33Attribute:{
      Mat33Attribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case Mat44Attribute:{
      Mat44Attribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case QuatAttribute:{
      QuatAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case RGBAAttribute:{
      RGBAAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case RGBAttribute:{
      RGBAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case ScalarAttribute:{
      ScalarAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case ScalarConstantArrayAttribute:{
      ScalarConstantArrayAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case SkinningAttribute:{
      SkinningAttribute colorAttr = attr;
      SkinningAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case UInt16ConstantArrayAttribute:{
      UInt16ConstantArrayAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case UInt32Attribute:{
      UInt32Attribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case Vec2Attribute:{
      Vec2Attribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case Vec3_dAttribute:{
      Vec3_dAttribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case Vec3Attribute:{
      Vec3Attribute clone();
      clone.copyFrom(src);
      return clone;
    }
    case Vec4Attribute:{
      Vec4Attribute clone();
      clone.copyFrom(src);
      return clone;
    }
  }
  throw("Invalid Attribute type:" + attr.type());
}


function Boolean applyNameFilter(String name, String filter){
  UInt32 result[];
  String filterStr = filter;
  Boolean wildCardStart = filter.startsWith("*");
  Boolean wildCardEnd = filter.endsWith("*");
  if(wildCardStart){
    filterStr = filterStr.subString(1, -1);
  }
  if(wildCardEnd){
    filterStr = filterStr.subString(0, filterStr.length()-2);
  }
  if(wildCardStart && name.endsWith(filterStr)){
    return true;
  }
  else if(wildCardEnd && name.startsWith(filterStr)){
    return true;
  }
  else if(name == filterStr){
    return true;
  }
  return false;
}



function Boolean applyNameFilters(String name, String filters[]){
  for(Integer i=0; i<filters.size; i++){
    if(applyNameFilter(name, filters[i])){
      return true;
    }
  }
  return false;
}

operator geometryAttributeCache_cloneColorAttr<<<index>>>(Color srcAttr<>, io Color tgtAttr<>){         tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneIntegerAttr<<<index>>>(Integer srcAttr<>, io Integer tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneMat33Attr<<<index>>>(Mat33 srcAttr<>, io Mat33 tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneMat44Attr<<<index>>>(Mat44 srcAttr<>, io Mat44 tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneQuatAttr<<<index>>>(Quat srcAttr<>, io Quat tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneRGBAAttr<<<index>>>(RGBA srcAttr<>, io RGBA tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneRGBAttr<<<index>>>(RGB srcAttr<>, io RGB tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneScalarAttr<<<index>>>(Scalar srcAttr<>, io Scalar tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneUInt16Attr<<<index>>>(UInt16 srcAttr<>, io UInt16 tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneUInt32Attr<<<index>>>(UInt32 srcAttr<>, io UInt32 tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneVec2Attr<<<index>>>(Vec2 srcAttr<>, io Vec2 tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneVec3Attr<<<index>>>(Vec3 srcAttr<>, io Vec3 tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }
operator geometryAttributeCache_cloneVec4Attr<<<index>>>(Vec4 srcAttr<>, io Vec4 tgtAttr<>){   tgtAttr[index] = srcAttr[index]; }

function GeometryAttribute cloneGPUAttribute(GeometryAttribute attr) {
  // Note: we need clone to be part of the Geometry interface. 
  Ref<Object> src = attr;
  switch(attr.type()){
    case ColorAttribute:{
      ColorAttribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneColorAttr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case IntegerAttribute:{
      IntegerAttribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneIntegerAttr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case Mat33Attribute:{
      Mat33Attribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneMat33Attr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case Mat44Attribute:{
      Mat44Attribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneMat44Attr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case QuatAttribute:{
      QuatAttribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneQuatAttr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case RGBAAttribute:{
      RGBAAttribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneRGBAAttr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case RGBAttribute:{
      RGBAttribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneRGBAttr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case ScalarAttribute:{
      ScalarAttribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneScalarAttr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case ScalarConstantArrayAttribute:{
      ScalarConstantArrayAttribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneScalarAttr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case SkinningAttribute:{
      // SkinningAttribute colorAttr = attr;
      // SkinningAttribute clone();
      // clone.resize(src.size());
      clone.values.values.convertToGPU();
      // geometryAttributeCache_cloneUInt16Attr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case UInt16ConstantArrayAttribute:{
      UInt16ConstantArrayAttribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneUInt16Attr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case UInt32Attribute:{
      UInt32Attribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneUInt32Attr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case Vec2Attribute:{
      Vec2Attribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneVec2Attr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case Vec3_dAttribute:{
      // Vec3_dAttribute clone();
      // clone.resize(src.size());
      clone.values.values.convertToGPU();
      // geometryAttributeCache_cloneRGBAttr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case Vec3Attribute:{
      Vec3Attribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneVec3Attr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
    case Vec4Attribute:{
      Vec4Attribute clone();
      clone.resize(src.size());
      clone.values.values.convertToGPU();
      geometryAttributeCache_cloneVec4Attr<<<scr.size()@useGPU>>>(src.values, clone.values);
      return clone;
    }
  }
  throw("Invalid Attribute type:" + attr.type());
}



function convertAttributeToGPU(GeometryAttribute attr) {
  // Note: we need clone to be part of the Geometry interface. 
  switch(attr.type()){
    case ColorAttribute:{
      ColorAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case IntegerAttribute:{
      IntegerAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case Mat33Attribute:{
      Mat33Attribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case Mat44Attribute:{
      Mat44Attribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case QuatAttribute:{
      QuatAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case RGBAAttribute:{
      RGBAAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case RGBAttribute:{
      RGBAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case ScalarAttribute:{
      ScalarAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case ScalarConstantArrayAttribute:{
      ScalarConstantArrayAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case SkinningAttribute:{
      // Moving the SkiningData to the GPU isn't possible, because to access the data, 
      // many functoins on the SkinningAttribute are used. (getPairs).
      // Its not possible to use the functions on the SkinningAttribute, because objects are not
      // supported on the GPU. 
      // Each of these methods would need to be re-implemented, and its quite complex stuff. 
      // Instead, the SkinningModifer extracts the data into simpler flat arrays and moves those
      // arrays to the GPU instead. 
      // SkinningAttribute concreteAttr = attr;
      // concreteAttr.weightsAllocator.convertToGPU();
      // concreteAttr.ids.convertToGPU();
      // concreteAttr.offsets.convertToGPU();
      // concreteAttr.counts.convertToGPU();
      break;
    }
    case UInt16ConstantArrayAttribute:{
      UInt16ConstantArrayAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case UInt32Attribute:{
      UInt32Attribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case Vec2Attribute:{
      Vec2Attribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case Vec3_dAttribute:{
      Vec3_dAttribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case Vec3Attribute:{
      Vec3Attribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    case Vec4Attribute:{
      Vec4Attribute concreteAttr = attr;
      concreteAttr.values.convertToGPU();
      break;
    }
    default:
      throw("Invalid Attribute type:" + attr.type());
  }
}


function Vec3 getPointPosition_GPU(UInt32 index, io Vec3 positions<>){
  return positions[index];
}

// offsets: a 1d array of indices into the indices array.
// indices: a 2d array of indices. each points attr indices are packed into a contiguous block.
function setPointPosition_GPU(UInt32 index, Vec3 position, io Vec3 positions<>, UInt32 offsets<>, UInt32 indices<>){
  UInt32 offset = offsets[index];
  UInt32 attrCount = (index < offsets.size ? offsets[index+1] : positions.size) - offset;
  for(UInt32 i=0; i<attrCount; i++){
    positions[indices[offset+i]] = position;
  }
}