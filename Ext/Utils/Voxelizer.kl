

// We need to add a hashing function so the Vec3_i can be added to dictionaries
// so we do that here for now
function UInt32 Vec3_i.hash()
{
    return this.x.hash() ^ this.y.hash() ^ this.z.hash();
}


struct Voxelizer {

  /// \internal
  Scalar cellSize;
  /// \internal
  Scalar cellSizeInv;
};

/// \dfgPresetDefault cellSize 1.0
/// \dfgPresetRange cellSize (0.01, 20.0)
function Voxelizer(Scalar cellSize)
{
  this.setCellSize(cellSize);
}


function Voxelizer.setCellSize!(Scalar cellSize)
{
  this.cellSize = cellSize;
  this.cellSizeInv = 1 / cellSize;
}


function Scalar Voxelizer.getCellSize()
{
  return this.cellSize;
} 


function Scalar Voxelizer.getCellSizeInv()
{
  return this.cellSizeInv;
} 


//////////////////////////////////////
// Voxelize
/// Borrowed from Voxelize preset node in FE 2.0
/// \internal
operator Voxelizer_VoxelizeTask<<<index>>>(in Voxelizer this,
                                           io Vec4_i[][] hLine,
                                           PolygonMesh   mesh,
                                           UInt32        numRayi,
                                           Vec3          vDir,
                                           Vec3          vPosStart,
                                           Vec3          vPosStartAddi,
                                           Vec3          vPosStartAddj)
{
  const Float32 epsilon = 0.001;

  // begin spatial query.
  Ref<SpatialQuery> query = mesh.beginSpatialQuery();

  // split index into row/column.
  UInt32 rayj = index / numRayi;
  UInt32 rayi = index - rayj * numRayi;
    
  // calculate ray's starting position.
  Vec3 rayPos = vPosStart + rayi * vPosStartAddi + rayj * vPosStartAddj;

  // declare and init security counter (to avoid a possible infinite loop due to rounding errors).
  UInt32 security = 1;

  // ray cast.
  while (true)
  {
    // get the intersection.
    Ray ray(rayPos, vDir);
    GeometryLocation gloc = query.raycast(ray, true, 0, SCALAR_INFINITE);

    // no hit?
    if (!gloc.isValid())
      break;

    // get the position at gloc.
    Vec3 glocPos = mesh.getPositionAtLocation(gloc);
    Vec3_i glocVoxelIndex = this.getVoxelIndex(glocPos);

    // set newLine's position from gloc and its length to 0.
    Vec4_i newLine;
    newLine.x = glocVoxelIndex.x;
    newLine.y = glocVoxelIndex.y;
    newLine.z = glocVoxelIndex.z;
    newLine.t = 0;

    // calculate ray's starting position for the second ray cast.
    rayPos = glocPos + epsilon * vDir;
    ray.set(rayPos, vDir);
    gloc = query.raycast(ray, true, 0, SCALAR_INFINITE);

    // no hit?
    if (!gloc.isValid())
    {
      // add newLine to hLine and break.
      hLine[index].push(newLine);
      break;
    }

    // get the position at gloc.
    glocPos = mesh.getPositionAtLocation(gloc);
    glocVoxelIndex = this.getVoxelIndex(glocPos);
          
    // set newLine's final length (in cells).
    newLine.t =   (glocVoxelIndex.x - newLine.x)
                + (glocVoxelIndex.y - newLine.y)
                + (glocVoxelIndex.z - newLine.z);

    // perform security check, calculate next ray's starting position and add newLine to hLine.
    if (newLine.t > 1)
    {
      security = 1;
      rayPos = glocPos + epsilon * vDir;
      hLine[index].push(newLine);
    }
    else
    {
      // is newLine identical with the last line in hLine?
      if (hLine[index].size() > 0 && newLine == hLine[index][hLine[index].size() - 1])
      {
        // increase the security and ignore newLine (i.e. don't add it to hLine).
        security++;
        rayPos = glocPos + epsilon * Float32(security) * vDir;
      }
      else
      {
        security = 1;
        rayPos = glocPos + epsilon * vDir;
        hLine[index].push(newLine);
      }
    }
  }

  // end spatial query.
  mesh.endSpatialQuery(query);
}


/// Borrowed from Voxelize preset node in FE 2.0
// Outputs:
//  hLine: hLine for all units in cells. (Voxel Space; integers); Single Vec4_i is x, y, z is line's starting position, t is line's length
//  bbSize: Bounding Box extends of the Voxel structure (World space size)
//  vDir: The raycast direction of the lines in hLine. The vector used for raycasting, its length is equal cellSize.
/// \dfgPresetDefault threading true
function Voxelizer.voxelize(in PolygonMesh mesh,
                            Integer projection, 
                            Integer acceleration, 
                            Boolean threading,
                            out Vec4_i hLine[][], 
                            out Vec3 bbSize,
                            out Vec3 vDir) 
{

  // check.
  if ( this.cellSizeInv < DIVIDEPRECISION
      || mesh == null
      || mesh.polygonCount() <= 0
      || mesh.triangleCount() <= 0)
    return;

  // get the bounding box of the mesh and snap its corners to the grid defined by cellSize.
  Vec3 bbMin;
  Vec3 bbMax;
  //Vec3 bbSize; 
  {
    // get the bounding box corners.
    LocalBoundingVolume bvol = mesh.getBoundingVolume();
    bbMin = bvol.bBoxGetMin();
    bbMax = bvol.bBoxGetMax();

    // snap bbmin to grid.
    bbMin  *= this.cellSizeInv;
    bbMin.x = floor(bbMin.x);
    bbMin.y = floor(bbMin.y);
    bbMin.z = floor(bbMin.z);
    bbMin  *= this.cellSize;

    // snap bbmax to grid.
    bbMax  *= this.cellSizeInv;
    bbMax.x = ceil(bbMax.x);
    bbMax.y = ceil(bbMax.y);
    bbMax.z = ceil(bbMax.z);
    bbMax  *= this.cellSize;
  
    // calculate size.
    bbSize = bbMax - bbMin;

    // bounding box no good?
    if (   bbSize.x <= 0
        || bbSize.y <= 0
        || bbSize.z <= 0)
      return;
  }
  
  // determine the plane for the ray casting.
  const Integer PLANE_XY = 1;
  const Integer PLANE_XZ = 2;
  const Integer PLANE_ZY = 3;
  Integer raycastPlane;
  switch (projection)
  {
    case PLANE_XY:
    case PLANE_XZ:
    case PLANE_ZY:
    {
      raycastPlane = projection;
      break;
    }
    default:
    {
      Float32 bbAreaXY = bbSize.x * bbSize.y;
      Float32 bbAreaXZ = bbSize.x * bbSize.z;
      Float32 bbAreaZY = bbSize.z * bbSize.y;
      if      (bbAreaXY <= bbAreaXZ && bbAreaXY <= bbAreaZY)  raycastPlane = PLANE_XY;
      else if (bbAreaXZ <= bbAreaXY && bbAreaXZ <= bbAreaZY)  raycastPlane = PLANE_XZ;
      else                                                    raycastPlane = PLANE_ZY;
      break;
    }            
  }
    
  // Define ray directions and steps
  {
    // calculate the amount of rays in i and j and init the vectors that will be used when casting the rays.
    UInt32 numRayi;
    UInt32 numRayj;
    Vec3 vPosStart     = bbMin;
    Vec3 vPosStartAddi = 0;
    Vec3 vPosStartAddj = 0;
    switch (raycastPlane)
    {
      case PLANE_XY:
        numRayi = round(bbSize.x * this.cellSizeInv);
        numRayj = round(bbSize.y * this.cellSizeInv);
        vDir         .z = this.cellSize;
        vPosStartAddi.x = this.cellSize;
        vPosStartAddj.y = this.cellSize;
        vPosStart    .z = vPosStart.z - this.cellSize;
        break;
      case PLANE_XZ:
        numRayi = round(bbSize.x * this.cellSizeInv);
        numRayj = round(bbSize.z * this.cellSizeInv);
        vDir         .y = this.cellSize;
        vPosStartAddi.x = this.cellSize;
        vPosStart    .y = vPosStart.y - this.cellSize;
        vPosStartAddj.z = this.cellSize;
        break;
      default:
        numRayi = round(bbSize.z * this.cellSizeInv);
        numRayj = round(bbSize.y * this.cellSizeInv);
        vDir         .x = this.cellSize;
        vPosStart    .x = vPosStart.x - this.cellSize;
        vPosStartAddj.y = this.cellSize;
        vPosStartAddi.z = this.cellSize;
        break;
    }
    vPosStart += 0.5 * (vPosStartAddi + vPosStartAddj);

    // init/set hLine[][].
    hLine.resize(numRayi * numRayj);

    // prepare mesh for spatial queries.
    GenericValueContainer options = GenericValueContainer();
    if (acceleration == 0)  PrepareForSpatialQueries_setOctree    (options);
    else                    PrepareForSpatialQueries_setSparseGrid(options);
    mesh.prepareForSpatialQueries(numRayi * numRayj, options);
    
    // fill hLine.
    if (threading || (!threading && hLine.size() < 32))
    {
      // singlethreaded.
      for (UInt32 i=0;i<hLine.size();i++)
        Voxelizer_VoxelizeTask(i, this, hLine, mesh, numRayi, vDir, vPosStart, vPosStartAddi, vPosStartAddj);
    }
    else
    {
      // multithreaded.
      Voxelizer_VoxelizeTask<<<hLine.size()>>>(this, hLine, mesh, numRayi, vDir, vPosStart, vPosStartAddi, vPosStartAddj);
    }
  }
}

// Get the voxel space index for a world space position
/// \internal
inline Vec3_i Voxelizer.getVoxelIndex(Vec3 pt)
{
  return Vec3_i( floor(pt.x * this.cellSizeInv), 
                 floor(pt.y * this.cellSizeInv),
                 floor(pt.z * this.cellSizeInv) );
}

// Get the voxel's center position in world space from a voxel space index
/// \internal
inline Vec3 Voxelizer.getVoxelCenter(Vec3_i voxelIndex)
{
  return Vec3( (voxelIndex.x * this.cellSize) + (0.5 * this.cellSize), 
               (voxelIndex.y * this.cellSize) + (0.5 * this.cellSize),
               (voxelIndex.z * this.cellSize) + (0.5 * this.cellSize));
}

// Voxel conversion from hLines to dictionary with Voxel space indices (Vec3_i)
// (we use dictionary to have sparse entries and perform quick hash lookup)
function Voxelizer.linesToVoxels(Vec4_i hLines[][],
                   Vec3 lineDirection,
                   out Boolean voxels[Vec3_i])
{
  //Boolean voxels[Vec3_i];
  {
    Vec4_i hLine;
    Scalar numCells; // number of cells (length) of the line
    Vec3_i voxelIndexStart; // voxel index start of line
    Vec3_i voxelIndex; // voxel index of the voxels in the line

    // Normalized line direction as integer vector in cell/voxel space
    Vec3 v = lineDirection.unit();
    Vec3_i directionCell(floor(v.x), floor(v.y), floor(v.z));

    for(Integer i=0; i<hLines.size(); i++)
    {
      for(Integer j=0; j<hLines[i].size(); j++)
      {
          hLine = hLines[i][j];
          voxelIndexStart = Vec3_i(hLine.x, hLine.y, hLine.z);
          numCells = hLine.t;
          // Define all voxels for this line.
          for(Integer x=0; x<numCells+1; x++)
          {
              voxelIndex = voxelIndexStart + (x * directionCell);
              voxels[voxelIndex] = true;
          }
      }
    }
  }
}

// Creates an Xfo array for each voxel in the hitlines
function Voxelizer.createXfos(Vec4_i hitlines[][],
                              Vec3 lineDirection,
                              out Xfo xfo[])
{
  // count the total amount of xfo.
  UInt32 count = 0;
  for (UInt32 i=0;i<hitlines.size();i++)
    for (UInt32 j=0;j<hitlines[i].size();j++)
      count += hitlines[i][j].t + 1;

  // resize and fill output.
  xfo.resize(count);
  count = 0;
  for (UInt32 i=0;i<hitlines.size();i++)
  {
    for (UInt32 j=0;j<hitlines[i].size();j++)
    {
      Vec3 p;
      p.x = this.cellSize * (0.5 + Float32(hitlines[i][j].x));
      p.y = this.cellSize * (0.5 + Float32(hitlines[i][j].y));
      p.z = this.cellSize * (0.5 + Float32(hitlines[i][j].z));

      for (UInt32 k=0;k<=hitlines[i][j].t;k++,count++)
      {
        xfo[count].ori = Quat();
        xfo[count].sc  = this.cellSize;
        xfo[count].tr  = p;
        p += lineDirection;
      }
    }
  }

}

// Creates a Lines object based on the hitlines
// Note that lines is `io` so that we can re-use an existing object
// change the points and perform 'incrementPositionsVersion()' instead
// of creating a new object each time
function Voxelizer.createLines(Vec4_i hitlines[][],
                              Vec3 lineDirection,
                              io Lines lines)
{
  // count the total amount of lines.
  UInt32 count = 0;
  for (UInt32 i=0;i<hitlines.size();i++)
    count += hitlines[i].size();

  // fill output.
  lines.addPoints(2 * count);
  count = 0;
  for (UInt32 i=0;i<hitlines.size();i++)
  {
    for (UInt32 j=0;j<hitlines[i].size();j++,count+=2)
    {
      Vec3 p;
      p.x = this.cellSize * (0.5 + Float32(hitlines[i][j].x));
      p.y = this.cellSize * (0.5 + Float32(hitlines[i][j].y));
      p.z = this.cellSize * (0.5 + Float32(hitlines[i][j].z));
      lines.setPosition(count + 0, p);
      lines.setPosition(count + 1, p + Float32(hitlines[i][j].t) * lineDirection);
      lines.addLine(count, count + 1);
    }
  }

  lines.incrementPositionsVersion();
}